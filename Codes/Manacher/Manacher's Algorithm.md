# Manacher's Algorithm

## 팰린드롬, 회문

팰린드롬 또는 회문이란, 거꾸로 읽어도 똑같은 문자열을 말한다.

예를 들어, ababa나 bcb는 팰린드롬이지만, abab는 팰린드롬이 아니다.

어떤 문자열이 팰린드롬인지 확인하는 방법은 여러가지가 있다.

```python
def is_palindrom(s):
    if s == s[::-1]:
        return True
   	else:
        return False
```

```python
def is_palindrom(s):
    n = len(s)
    for i in range(n//2):
        if s[i] != s[n-1-i]:
            return False
    return True
```

```python
def is_palindrome(s):
    if len(s) < 2:
        return True
    if s[0] == s[-1]:
        return is_palindrome(s[1:-1])
    else:
        return False
```



<br/>

### 가장 긴 팰린드롬 부분 문자열

만약 문자열 중 팰린드롬이면서 가장 긴 부분 문자열을 찾고 싶다면 어떨까

위와 같은 방법으로 찾으려면 O(N^2)이 걸릴 것이다.

이에 비해, Manacher's 알고리즘을 사용하면 O(N)만에 찾을 수 있다.



## Manacher's Algorithm

### 아이디어

Manacher의 기본적인 아이디어는 다음과 같다.

- "abacaba"라는 문자열이 있을 때, 앞에서부터 각 문자를 중심으로 하는 가장 긴 팰린드롬의 길이를 구한다.
- 그러다가 "c"를 중심으로 하는 가장 긴 팰린드롬의 길이를 구한다.

- "c" 이후에 나오는 "a"를 중심으로 하는 팰린드롬 문자열은 **최소한** "c" 앞에 나온 "a"를 중심으로 하는 팰린드롬 문자열보다는 길거나 같을 것이다.

- 마찬가지로 "c"이후에 나오는 "b"를 중심으로 하는 팰린드롬 문자열은  **최소한** "c" 앞에 나온 "b"를 중심으로 하는 팰린드롬 문자열보다는 길거나 같을 것이다.

이처럼 "앞에서 구해놓은 가장 긴 팰린드롬 문자열"에 속하는 문자를 중심으로 하는 팰린드롬 문자열의 최소 길이를 알고 있으므로 계산 속도를 높이게 된다.

### 수도 코드

```python
def manachers(S, n):
    r = c = -1
    P = [0] * n
    for i in range(n):
        if r >= i:
            P[i] = min(r - i, P[c * 2 - i])
        else:
            P[i] = 0

        while 0 <= i - P[i] - 1 < i + P[i] + 1 < n:
            if S[i + P[i] + 1] == S[i - P[i] - 1]:
                P[i] += 1
            else:
                break

        if i + P[i] > r:
            r = i + P[i]
            c = i

    return P
```

#### 설명

##### 변수들

```
P : S[i]를 중심으로 하는 최장 팰린드롬 문자열 반지름 저장 배열
r : 현재까지의 팰린드롬 문자열에 포함되는 문자들 중 가장 오른쪽인 인덱스
c : 현재까지의 팰린드롬 문자열의 중심 중 가장 오른쪽인 인덱스
```



##### if...else 문

```python
if r >= i:
	P[i] = min(r - i, P[c * 2 - i])
else:
    P[i] = 0
```

- `r >= i` 인 경우

  즉, 현재 `i`번째 문자는 이전에 구해놓은 가장 긴 팰린드롬 문자열의 내부에 들어있다.

  `i`번째 문자가 팰린드롬 내부에 있으므로 `i`와 대칭인 `i'` (=c+c-i)번째 문자는 `i`번째 문자와 같다.

  더 나아가, `i'`번째 문자를 중심으로 하는 팰린드롬과 `c`번째 문자를 중심으로 하는 팰린드롬이 겹치는 부분은 `i`번째 문자를 중심으로 하는 팰린드롬 문자와 같다.

  그리고 그런 부분의 반지름은 `min(r- i, P[c * 2 - i])`다.



​		`r - i` : `c`번째 문자를 중심으로 하는 팰린드롬의 반지름

​		`P[c * 2 - i]`  : `i'`번째 문자를 중심으로 하는 팰린드롬의 반지름



​	따라서 `i`번째 문자를 중심으로 하는 최장 팰린드롬을 찾을 때,

​	`P[i] = min(r- i, P[c * 2 - i])` 부터 시작해 찾아보면된다.



- `r < i` 인 경우

  현재 `i`번째 문자는 이전에 구해놓은 가장 긴 팰린드롬 문자열의 밖에 있다.

  이 경우는 처음부터 팰린드롬 검사를 시작하면 된다. 따라서

  `P[i] = 0` 부터 시작한다.



##### while 문

```python
while 0 <= i - P[i] - 1 < i + P[i] + 1 < n:
            if S[i + P[i] + 1] == S[i - P[i] - 1]:
                P[i] += 1
            else:
                break
```



앞에서 찾은 최소 길이 `P[i]`부터 시작해서 최장 팰린드롬의 반지름을 찾아나간다.



##### 마지막 if문

```python
if i + P[i] > r:
            r = i + P[i]
            c = i
```

`i + P[i]` 는 `i`번째 문자를 중심으로 하는 최장 팰린드롬의 문자열의 오른쪽 끝 인덱스를 의미하게 된다. `i`가 중심, `P[i]`가 반지름이기 때문.

따라서 `r` 과 `c`를 다시 갱신해준다.

